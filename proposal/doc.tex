\documentclass[letterpaper]{article}
\usepackage[margin=1in]{geometry}
\usepackage[shortlabels]{enumitem}
\usepackage{amsmath,amssymb,amsthm,dsfont}
\usepackage{setspace,parskip,multicol,titling}

\newcommand{\R}{\mathds{R}}
\newcommand{\Z}{\mathds{Z}}
\newcommand{\Q}{\mathds{Q}}
\newcommand{\C}{\mathds{C}}

\newcommand{\nope}{\textbf{DO THIS}}
\newcommand{\group}[1]{\langle \, #1 \, \rangle}
\renewcommand{\b}[1]{\textbf{#1}}

\setlength{\droptitle}{-1cm}
\setlength\parindent{30pt}
\setlength\parskip{8pt}
\setstretch{1.60}
\setlist{leftmargin=0.25in}

\title{CSC 258 Project Proposal}
\author{Brandon Willett}

\begin{document}

	\maketitle

	\section{Introduction}

	I don't really play video games anymore, but back when I was in high school, it was the main way my friends and I would pass the time after classes let out. The one we played the most was called World of Warcraft, where you play as an Elf or an Orc (or something), and you'd complete quests to level up and get better gear for your character. Doing quests was fun, but my favorite part of the game came only at the end, when you reached the maximum level -- then, you could start doing ``raids'', where groups of up to 40 players would team up and attempt to defeat massive boss enemies together. These bosses had abilities that could wipe out your entire team in one shot, so not only were individual players' skill and reaction times important, but also the overall group's composition: if you had too many high-damage-output members, the whole team would die before the boss could be killed, since those types tend to be fragile. Or, if you had too many healing characters, the entire raid might never end, since you might never kill a boss at all!

	These exercises in teamwork and perseverance were a lot of fun for me at the time, and in fact they represent a pretty complicated distributed system. There are 40 players all rapidly sending commands to a central location which affect the boss's health and condition, and each of these players need there to be almost zero latency and perfect delivery of their messages, which -- when the ``central location'' is made up of many machines which might fail -- is hard to accomplish; the continuous synchronization of these messages is a challenge. In addition, each client needs to not only send ``damage the boss'' messages to the central location, but also to listen for ``you've been healed'' messages back from others. This sort of player-count-agnostic system is required, since at any one time there might be 4 or 40 players sending messages at once, and this too presents an interesting issue.

	Thus, we reach the idea of my project, which is to implement a simplified version of this game as a command line app in Elixir. At any time, a client can ``join the fight'' either as a healer or a damage character. Then, they'll have a set of commands they can send to the remote server, like querying the boss's current health or executing a move to heal a friend whose character is in danger of dying. While Elixir as a language (being focused on many independent message-passing processes) is a great fit for the task, it also represents the ``hard part'' of this project, since up until this point I'd never used the language before, and this style of programming requires a very different mindset than usual.

	\section{Outline}

	One reason that Elixir was a good choice to model this task is that its OTP (Open Telecom Platform, inherited from Erlang) framework was designed to make this exact type of program easy to write. The general model relies on a large number of cheap independent processes, which can be distributed just as easily among the system threads of one computer or the machines of a server farm. Each process has its own state that it manages, and they can affect each others' states only via message passing, which also scales in a simple and easy way. The only trouble is, with that many concurrent processes all running at once, the chance of a process failing is high, and in normal circumstances, one important process failing brings down the whole system. To combat this, the OTP model makes extensive use of ``Supervisors'' -- processes whose only job is to monitor other processes, and cleanly restart them if they fail. In this way, a well-designed Elixir application can have any number of failing worker processes, and a user would never notice.

	In our Elixir game, 

\end{document}








